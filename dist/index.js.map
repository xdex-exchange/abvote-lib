{"version":3,"sources":["../src/algorithm/math.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/_version.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/properties.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/errors.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/data.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/maths.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/utf8.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/fixednumber.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/utils/units.ts","../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/src/_assert.ts","../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/src/_u64.ts","../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/src/utils.ts","../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/src/sha3.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/crypto/keccak.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/address/address.ts","../node_modules/.pnpm/ethers@6.13.5/node_modules/ethers/src.ts/hash/solidity.ts","../src/constants/constants.ts","../src/types/types.ts","../src/algorithm/exponent.ts","../src/algorithm/indexPrice.ts","../src/algorithm/oracle.ts"],"sourcesContent":["import Decimal from \"decimal.js\";\n\n/**\n * Computes the log return (Logarithmic Return)\n *\n * Formula:\n *    r = ln(P_t / P_{t-1})\n *\n * Description:\n *    - P_t: current price\n *    - P_{t-1}: previous price\n *    - Returns 0 if either price is non-positive\n */\nexport const computeLogReturn = (\n  current: Decimal,\n  previous: Decimal\n): Decimal => {\n  if (previous.lte(0) || current.lte(0)) return new Decimal(0);\n  return current.div(previous).log(); // ln(current / previous)\n};\n\n/**\n * Tanh buffer delta to make it gradually slow as it approaches ± maxPercent\n * @param delta Original Δ\n * @param maxDelta Maximum price limit (logarithm)\n * @returns Δ after smoothing\n */\nexport function tanhClampDelta(delta: Decimal, maxPercent: number): Decimal {\n  const maxDelta = Decimal.ln(1 + maxPercent / 100);\n  //  tanh(delta / maxDelta) ∈ [-1, 1]，Multiplyback maxDelta after range ∈ [-maxDelta, +maxDelta]\n  return Decimal.tanh(delta.div(maxDelta)).mul(maxDelta);\n}\n\nexport function computeVolatility(deltas: Decimal[]): Decimal {\n  if (!deltas.length) return new Decimal(0);\n  const sum = deltas.reduce((acc, d) => acc.add(d.abs()), new Decimal(0));\n  return sum.div(deltas.length);\n}\n\nexport function applyFinalAsymmetricNoise(\n  baseMultiplier: Decimal,\n  tokenDelta: Decimal,\n  options?: {\n    asymmetryStrength?: number; // default: 0.005\n    randomness?: number; // default: 0.003\n  }\n): Decimal {\n  const asymmetryStrength = options?.asymmetryStrength ?? 0.06;\n  const randomness = options?.randomness ?? 0.003;\n\n  const directionalBias = tokenDelta.clamp(-1, 1).mul(asymmetryStrength);\n\n  const noise = new Decimal(Math.random() * randomness - randomness / 2);\n\n  const finalMultiplier = baseMultiplier.mul(\n    Decimal.exp(directionalBias.add(noise))\n  );\n\n  return finalMultiplier;\n}\n\nexport function applyVolatilityNoise(\n  delta: Decimal,\n  options?: {\n    volatilityAmplifier?: number; // default: 1.2\n    noiseRange?: number; // default: 0.002\n  }\n): Decimal {\n  const amplifier = new Decimal(options?.volatilityAmplifier ?? 1.115);\n  const noiseRange = options?.noiseRange ?? 0.015;\n\n  // Step 1: Amplify based on the absolute value of delta\n  const amplified = delta.mul(Decimal.pow(delta.abs().add(1), amplifier));\n\n  // Step 2: Add small noise\n  const noise = new Decimal(Math.random() * noiseRange - noiseRange / 2);\n\n  return amplified.add(noise);\n}\n","/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n\n/**\n *  The current version of Ethers.\n */\nexport const version: string = \"6.13.5\";\n","/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\n\nfunction checkType(value: any, type: string, name: string): void {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof(value) === type) { return; }\n        }\n    }\n\n    const error: any = new Error(`invalid value for type ${ type }`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${ name }`;\n    error.value = value;\n\n    throw error;\n}\n\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, <{ [ P in keyof T]: T[P] }>{ });\n}\n\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n","/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\nimport { version } from \"../_version.js\";\n\nimport { defineProperties } from \"./properties.js\";\n\nimport type {\n    TransactionRequest, TransactionReceipt, TransactionResponse\n} from \"../providers/index.js\";\n\nimport type { FetchRequest, FetchResponse } from \"./fetch.js\";\n\n/**\n *  An error may contain additional properties, but those must not\n *  conflict with any implicit properties.\n */\nexport type ErrorInfo<T> = Omit<T, \"code\" | \"name\" | \"message\" | \"shortMessage\"> & { shortMessage?: string };\n\n\nfunction stringify(value: any): any {\n    if (value == null) { return \"null\"; }\n\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n\n    if (typeof(value) === \"object\" && typeof(value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n\n    switch (typeof(value)) {\n        case \"boolean\": case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${ stringify(k) }: ${ stringify(value[k]) }`).join(\", \") + \" }\";\n        }\n    }\n\n    return `[ COULD NOT SERIALIZE ]`;\n}\n\n/**\n *  All errors emitted by ethers have an **ErrorCode** to help\n *  identify and coalesce errors to simplify programmatic analysis.\n *\n *  Each **ErrorCode** is the %%code%% proerty of a coresponding\n *  [[EthersError]].\n *\n *  **Generic Errors**\n *\n *  **``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n *\n *  **``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n *\n *  **``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n *\n *  **``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n *\n *  **``\"SERVER_ERROR\"``** - see [[ServerError]]\n *\n *  **``\"TIMEOUT\"``** - see [[TimeoutError]]\n *\n *  **``\"BAD_DATA\"``** - see [[BadDataError]]\n *\n *  **``\"CANCELLED\"``** - see [[CancelledError]]\n *\n *  **Operational Errors**\n *\n *  **``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n *\n *  **``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n *\n *  **Argument Errors**\n *\n *  **``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n *\n *  **``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n *\n *  **``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n *\n *  **``\"VALUE_MISMATCH\"``** - //unused//\n *\n *  **Blockchain Errors**\n *\n *  **``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n *\n *  **``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n *\n *  **``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n *\n *  **``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n *\n *  **``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n *\n *  **``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n *\n *  **``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n *\n *  **User Interaction Errors**\n *\n *  **``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]\n */\nexport type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVALID_ARGUMENT\" | \"MISSING_ARGUMENT\" | \"UNEXPECTED_ARGUMENT\" |\n    \"VALUE_MISMATCH\" |\n\n    // Blockchain Errors\n    \"CALL_EXCEPTION\" | \"INSUFFICIENT_FUNDS\" | \"NONCE_EXPIRED\" |\n    \"REPLACEMENT_UNDERPRICED\" | \"TRANSACTION_REPLACED\" |\n    \"UNCONFIGURED_NAME\" | \"OFFCHAIN_FAULT\" |\n\n    // User Interaction\n    \"ACTION_REJECTED\"\n;\n\n/**\n *  All errors in Ethers include properties to assist in\n *  machine-readable errors.\n */\nexport interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additional info regarding the error that may be useful.\n     *\n     *  This is generally helpful mostly for human-based debugging.\n     */\n    info?: Record<string, any>;\n\n    /**\n     *  Any related error.\n     */\n    error?: Error;\n}\n\n// Generic Errors\n\n/**\n *  This Error is a catch-all for when there is no way for Ethers to\n *  know what the underlying problem is.\n */\nexport interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}\n\n/**\n *  This Error is mostly used as a stub for functionality that is\n *  intended for the future, but is currently not implemented.\n */\nexport interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates that the attempted operation is not supported.\n *\n *  This could range from a specific JSON-RPC end-point not supporting\n *  a feature to a specific configuration of an object prohibiting the\n *  operation.\n *\n *  For example, a [[Wallet]] with no connected [[Provider]] is unable\n *  to send a transaction.\n */\nexport interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates a problem connecting to a network.\n */\nexport interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}\n\n/**\n *  This Error indicates there was a problem fetching a resource from\n *  a server.\n */\nexport interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}\n\n/**\n *  This Error indicates that the timeout duration has expired and\n *  that the operation has been implicitly cancelled.\n *\n *  The side-effect of the operation may still occur, as this\n *  generally means a request has been sent and there has simply\n *  been no response to indicate whether it was processed or not.\n */\nexport interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}\n\n/**\n *  This Error indicates that a provided set of data cannot\n *  be correctly interpreted.\n */\nexport interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}\n\n/**\n *  This Error indicates that the operation was cancelled by a\n *  programmatic call, for example to ``cancel()``.\n */\nexport interface CancelledError extends EthersError<\"CANCELLED\"> {\n}\n\n\n// Operational Errors\n\n/**\n *  This Error indicates an attempt was made to read outside the bounds\n *  of protected data.\n *\n *  Most operations in Ethers are protected by bounds checks, to mitigate\n *  exploits when parsing data.\n */\nexport interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n}\n\n/**\n *  This Error indicates an operation which would result in incorrect\n *  arithmetic output has occurred.\n *\n *  For example, trying to divide by zero or using a ``uint8`` to store\n *  a negative value.\n */\nexport interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}\n\n\n// Argument Errors\n\n/**\n *  This Error indicates an incorrect type or value was passed to\n *  a function or method.\n */\nexport interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}\n\n/**\n *  This Error indicates there were too few arguments were provided.\n */\nexport interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n/**\n *  This Error indicates too many arguments were provided.\n */\nexport interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n\n// Blockchain Errors\n\n/**\n *  The action that resulted in the call exception.\n */\nexport type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";\n\n/**\n *  The related transaction that caused the error.\n */\nexport type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};\n\n/**\n *  This **Error** indicates a transaction reverted.\n */\nexport interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-readable representation of data, if possible.\n     */\n    reason: null | string;\n\n    /**\n     *  The transaction that triggered the exception.\n     */\n    transaction: CallExceptionTransaction,\n\n    /**\n     *  The contract invocation details, if available.\n     */\n    invocation: null | {\n        method: string;\n        signature: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  The built-in or custom revert error, if available\n     */\n    revert: null | {\n        signature: string;\n        name: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  If the error occurred in a transaction that was mined\n     *  (with a status of ``0``), this is the receipt.\n     */\n    receipt?: TransactionReceipt;   // @TODO: in v7, make this `null | TransactionReceipt`\n}\n\n\n/**\n *  The sending account has insufficient funds to cover the\n *  entire transaction cost.\n */\nexport interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  The sending account has already used this nonce in a\n *  transaction that has been included.\n */\nexport interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A CCIP-read exception, which cannot be recovered from or\n *  be further processed.\n */\nexport interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}\n\n/**\n *  An attempt was made to replace a transaction, but with an\n *  insufficient additional fee to afford evicting the old\n *  transaction from the memory pool.\n */\nexport interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A pending transaction was replaced by another.\n */\nexport interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was replaced.\n     */\n    reason: \"repriced\" | \"cancelled\" | \"replaced\";\n\n    /**\n     *  The hash of the replaced transaction.\n     */\n    hash: string;\n\n    /**\n     *  The transaction that replaced the transaction.\n     */\n    replacement: TransactionResponse;\n\n    /**\n     *  The receipt of the transaction that replace the transaction.\n     */\n    receipt: TransactionReceipt;\n}\n\n/**\n *  This Error indicates an ENS name was used, but the name has not\n *  been configured.\n *\n *  This could indicate an ENS name is unowned or that the current\n *  address being pointed to is the [[ZeroAddress]].\n */\nexport interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}\n\n/**\n *  This Error indicates a request was rejected by the user.\n *\n *  In most clients (such as MetaMask), when an operation requires user\n *  authorization (such as ``signer.sendTransaction``), the client\n *  presents a dialog box to the user. If the user denies the request\n *  this error is thrown.\n */\nexport interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n     *  If there is already a pending request, some clients may indicate\n     *  there is already a ``\"pending\"`` action. This prevents an app\n     *  from spamming the user.\n     */\n    reason: \"expired\" | \"rejected\" | \"pending\"\n}\n\n// Coding; converts an ErrorCode its Typed Error\n\n/**\n *  A conditional type that transforms the [[ErrorCode]] T into\n *  its EthersError type.\n *\n *  @flatworm-skip-docs\n */\nexport type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T extends \"TIMEOUT\" ? TimeoutError:\n    T extends \"BAD_DATA\" ? BadDataError:\n    T extends \"CANCELLED\" ? CancelledError:\n\n    T extends \"BUFFER_OVERRUN\" ? BufferOverrunError:\n    T extends \"NUMERIC_FAULT\" ? NumericFaultError:\n\n    T extends \"INVALID_ARGUMENT\" ? InvalidArgumentError:\n    T extends \"MISSING_ARGUMENT\" ? MissingArgumentError:\n    T extends \"UNEXPECTED_ARGUMENT\" ? UnexpectedArgumentError:\n\n    T extends \"CALL_EXCEPTION\" ? CallExceptionError:\n    T extends \"INSUFFICIENT_FUNDS\" ? InsufficientFundsError:\n    T extends \"NONCE_EXPIRED\" ? NonceExpiredError:\n    T extends \"OFFCHAIN_FAULT\" ? OffchainFaultError:\n    T extends \"REPLACEMENT_UNDERPRICED\" ? ReplacementUnderpricedError:\n    T extends \"TRANSACTION_REPLACED\" ? TransactionReplacedError:\n    T extends \"UNCONFIGURED_NAME\" ? UnconfiguredNameError:\n\n    T extends \"ACTION_REJECTED\" ? ActionRejectedError:\n\n    never;\n\n\n\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}\n\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nexport function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${ stringify(info) }`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") { continue; }\n                const value = <any>(info[<keyof ErrorInfo<T>>key]);\n//                try {\n                    details.push(key + \"=\" + stringify(value));\n//                } catch (error: any) {\n//                console.log(\"MMM\", error.message);\n//                    details.push(key + \"=[could not serialize object]\");\n//                }\n            }\n        }\n        details.push(`code=${ code }`);\n        details.push(`version=${ version }`);\n\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n\n    defineProperties<EthersError>(<EthersError>error, { code });\n\n    if (info) { Object.assign(error, info); }\n\n    if ((<any>error).shortMessage == null) {\n        defineProperties<EthersError>(<EthersError>error, { shortMessage });\n    }\n\n    return <T>error;\n}\n\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}\n\n\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\n\nexport function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\n\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") { throw new Error(\"bad\"); };\n        /* c8 ignore stop */\n\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301)\n            /* c8 ignore start */\n            if (check !== expected) { throw new Error(\"broken\") }\n            /* c8 ignore stop */\n        }\n\n        accum.push(form);\n    } catch(error) { }\n\n    return accum;\n}, <Array<string>>[]);\n\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${ method }from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n","/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n    if (value instanceof Uint8Array) {\n        if (copy) { return new Uint8Array(value); }\n        return value;\n    }\n\n    if (typeof(value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}\n\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (length === true && (value.length % 2) !== 0) { return false; }\n\n    return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0: start, (end == null) ? bytes.length: end));\n}\n\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}\n","/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n/**\n *  Any type that can be used where a numeric value is needed.\n */\nexport type Numeric = number | bigint;\n\n/**\n *  Any type that can be used where a big number is needed.\n */\nexport type BigNumberish = string | Numeric;\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n\n    return value;\n}\n\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    } else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n\n    return value;\n}\n\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch(e: any) {\n                assertArgument(false, `invalid BigNumberish string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\n\nconst Nibbles = \"0123456789abcdef\";\n\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n    return getBigInt(value);\n}\n\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                return getNumber(BigInt(value), name);\n            } catch(e: any) {\n                assertArgument(false, `invalid numeric string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n\n\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}\n\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${ width } bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n\n        // Pad the value to the required width\n        while (result.length < (width * 2)) { result = \"0\" + result; }\n\n    }\n\n    return \"0x\" + result;\n}\n\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n\n    return result;\n}\n\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}\n","/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument, assertNormalize } from \"./errors.js\";\n\nimport type { BytesLike } from \"./index.js\";\n\n\n///////////////////////////////\n\n/**\n *  The stanard normalization forms.\n */\nexport type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";\n\n/**\n *  When using the UTF-8 error API the following errors can be intercepted\n *  and processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n *\n *  **``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\n *  was nothing to continue.\n *\n *  **``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\n *  UTF-8 codepoint was found.\n *\n *  **``\"OVERRUN\"``** - the string is too short to process the expected\n *  codepoint length.\n *\n *  **``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\n *  not found. The %%offset%% indicates the index the continuation byte\n *  was expected at.\n *\n *  **``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\n *  for UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\n *  outside the valid UTF-8 range.\n *\n *  **``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\n *  pair. The %%badCodepoint%% is the computed codepoint, which was inside the\n *  UTF-16 surrogate range.\n *\n *  **``\"OVERLONG\"``** - the string is an overlong representation. The\n *  %%badCodepoint%% indicates the computed codepoint, which has already\n *  been bounds checked.\n *\n *\n *  @returns string\n */\nexport type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";\n\n\n/**\n *  A callback that can be used with [[toUtf8String]] to analysis or\n *  recovery from invalid UTF-8 data.\n *\n *  Parsing UTF-8 data is done through a simple Finite-State Machine (FSM)\n *  which calls the ``Utf8ErrorFunc`` if a fault is detected.\n *\n *  The %%reason%% indicates where in the FSM execution the fault\n *  occurred and the %%offset%% indicates where the input failed.\n *\n *  The %%bytes%% represents the raw UTF-8 data that was provided and\n *  %%output%% is the current array of UTF-8 code-points, which may\n *  be updated by the ``Utf8ErrorFunc``.\n *\n *  The value of the %%badCodepoint%% depends on the %%reason%%. See\n *  [[Utf8ErrorReason]] for details.\n *\n *  The function should return the number of bytes that should be skipped\n *  when control resumes to the FSM.\n */\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;\n\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n    assertArgument(false, `invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        assertArgument(typeof(badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nexport const Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    const bytes = getBytes(_bytes, \"bytes\");\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength: null | number = null;\n        let overlongMask: null | number = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res: null | number = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n    assertArgument(typeof(str) === \"string\", \"invalid string value\", \"str\", str);\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result: Array<number> = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            assertArgument(i < str.length && ((c2 & 0xfc00) === 0xdc00),\n                \"invalid surrogate pair\", \"str\", str);\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return new Uint8Array(result);\n};\n\n//export \nfunction _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n\n","/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport {\n    getBigInt, getNumber, fromTwos, mask, toBigInt\n} from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\n\nimport type { BigNumberish, BytesLike, Numeric } from \"./index.js\";\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\n\nconst _guard = { };\n\n\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) { Zeros += Zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals: number): bigint {\n    let result = Zeros;\n    while (result.length < decimals) { result += result; }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\n\n\n\n    /*\n     *  Returns a new FixedFormat for %%value%%.\n     *\n     *  If %%value%% is specified as a ``number``, the bit-width is\n     *  128 bits and %%value%% is used for the ``decimals``.\n     *\n     *  A string %%value%% may begin with ``fixed`` or ``ufixed``\n     *  for signed and unsigned respectfully. If no other properties\n     *  are specified, the bit-width is 128-bits with 18 decimals.\n     *\n     *  To specify the bit-width and demicals, append them separated\n     *  by an ``\"x\"`` to the %%value%%.\n     *\n     *  For example, ``ufixed128x18`` describes an unsigned, 128-bit\n     *  wide format with 18 decimals.\n     *\n     *  If %%value%% is an other object, its properties for ``signed``,\n     *  ``width`` and ``decimals`` are checked.\n     */\n\n/**\n *  A description of a fixed-point arithmetic field.\n *\n *  When specifying the fixed format, the values override the default of\n *  a ``fixed128x18``, which implies a signed 128-bit value with 18\n *  decimals of precision.\n *\n *  The alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n *  ``ufixed128x18`` respectively.\n *\n *  When a fixed format string begins with a ``u``, it indicates the field\n *  is unsigned, so any negative values will overflow. The first number\n *  indicates the bit-width and the second number indicates the decimal\n *  precision.\n *\n *  When a ``number`` is used for a fixed format, it indicates the number\n *  of decimal places, and the default width and signed-ness will be used.\n *\n *  The bit-width must be byte aligned and the decimals can be at most 80.\n */\nexport type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};\n\nfunction checkValue(val: bigint, format: _FixedFormat, safeOp?: string): bigint {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        } else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n\n    } else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n\n    return val;\n}\n\ntype _FixedFormat = { signed: boolean, width: number, decimals: number, name: string }\n\nfunction getFormat(value?: FixedFormat): _FixedFormat {\n    if (typeof(value) === \"number\") { value = `fixed128x${value}` }\n\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n\n    if (typeof(value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v: any = value;\n        const check = (key: string, type: string, defaultValue: any): any => {\n            if (v[key] == null) { return defaultValue; }\n            assertArgument(typeof(v[key]) === type,\n                \"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, v[key]);\n            return v[key];\n        }\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n\n    const name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n    return { signed, width, decimals, name };\n}\n\nfunction toString(val: bigint, decimals: number) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n\n    let str = val.toString();\n\n    // No decimal point for whole values\n    if (decimals === 0) { return (negative + str); }\n\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) { str = Zeros + str; }\n\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n\n    return (negative + str);\n}\n\n\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maintain the magnitude\n    readonly #tens: bigint;\n\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    readonly _value!: string;\n\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, value: bigint, format: any) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n\n        this.#val = value;\n\n        this.#format = format;\n\n        const _value = toString(value, format.decimals);\n\n        defineProperties<FixedNumber>(this, { format: format.name, _value });\n\n        this.#tens = getTens(format.decimals);\n    }\n\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed(): boolean { return this.#format.signed; }\n\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width(): number { return this.#format.width; }\n\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals(): number { return this.#format.decimals; }\n\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value(): bigint { return this.#val; }\n\n    #checkFormat(other: FixedNumber): void {\n        assertArgument(this.format === other.format,\n            \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n\n    #checkValue(val: bigint, safeOp?: string): FixedNumber {\n/*\n        const width = BigInt(this.width);\n        if (this.signed) {\n            const limit = (BN_1 << (width - BN_1));\n            assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n\n            if (val > BN_0) {\n                val = fromTwos(mask(val, width), width);\n            } else {\n                val = -fromTwos(mask(-val, width), width);\n            }\n\n        } else {\n            const masked = mask(val, width);\n            assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n            val = masked;\n        }\n*/\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n\n    #add(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other: FixedNumber): FixedNumber { return this.#add(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other: FixedNumber): FixedNumber { return this.#add(other, \"add\"); }\n\n    #sub(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other: FixedNumber): FixedNumber { return this.#sub(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other: FixedNumber): FixedNumber { return this.#sub(other, \"sub\"); }\n\n    #mul(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other: FixedNumber): FixedNumber { return this.#mul(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other: FixedNumber): FixedNumber { return this.#mul(other, \"mul\"); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other: FixedNumber): FixedNumber {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n\n    #div(o: FixedNumber, safeOp?: string): FixedNumber {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other: FixedNumber): FixedNumber { return this.#div(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other: FixedNumber): FixedNumber { return this.#div(other, \"div\"); }\n\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other: FixedNumber): FixedNumber {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n     cmp(other: FixedNumber): number {\n         let a = this.value, b = other.value;\n\n         // Coerce a and b to the same magnitude\n         const delta = this.decimals - other.decimals;\n         if (delta > 0) {\n             b *= getTens(delta);\n         } else if (delta < 0) {\n             a *= getTens(-delta);\n         }\n\n         // Comnpare\n         if (a < b) { return -1; }\n         if (a > b) { return 1; }\n         return 0;\n     }\n\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n     eq(other: FixedNumber): boolean { return this.cmp(other) === 0; }\n\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n     lt(other: FixedNumber): boolean { return this.cmp(other) < 0; }\n\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n     lte(other: FixedNumber): boolean { return this.cmp(other) <= 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n     gt(other: FixedNumber): boolean { return this.cmp(other) > 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n     gte(other: FixedNumber): boolean { return this.cmp(other) >= 0; }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor(): FixedNumber {\n        let val = this.#val;\n        if (this.#val < BN_0) { val -= this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling(): FixedNumber {\n        let val = this.#val;\n        if (this.#val > BN_0) { val += this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) { return this; }\n\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n\n        checkValue(value, this.#format, \"round\");\n\n        return new FixedNumber(_guard, value, this.#format);\n    }\n\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero(): boolean { return (this.#val === BN_0); }\n\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative(): boolean { return (this.#val < BN_0); }\n\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString(): string { return this._value; }\n\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format: FixedFormat): FixedNumber {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value: BigNumberish, _decimals?: Numeric, _format?: FixedFormat): FixedNumber {\n        const decimals = (_decimals == null) ? 0: getNumber(_decimals);\n        const format = getFormat(_format);\n\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n\n        checkValue(value, format, \"fromValue\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value: string, _format?: FixedFormat): FixedNumber {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n\n        const format = getFormat(_format);\n\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n\n        // Pad out the decimals\n        while (decimal.length < format.decimals) { decimal += Zeros; }\n\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n\n        const value = BigInt(match[1] + whole + decimal)\n\n        checkValue(value, format, \"fromString\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value: BytesLike, _format?: FixedFormat): FixedNumber {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n\n        if (format.signed) { value = fromTwos(value, format.width); }\n\n        checkValue(value, format, \"fromBytes\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n}\n\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n","/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\nimport { assertArgument } from \"./errors.js\";\nimport { FixedNumber } from \"./fixednumber.js\";\nimport { getNumber } from \"./maths.js\";\n\nimport type { BigNumberish, Numeric } from \"../utils/index.js\";\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nexport function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n\n    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nexport function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n\n    return FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nexport function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}\n\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nexport function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}\n","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    exists(this, false);\n    bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n","/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\n\nimport { keccak_256 } from \"@noble/hashes/sha3\";\n\nimport { getBytes, hexlify } from \"../utils/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\n\nlet locked = false;\n\nconst _keccak256 = function(data: Uint8Array): Uint8Array {\n    return keccak_256(data);\n}\n\nlet __keccak256: (data: Uint8Array) => BytesLike = _keccak256;\n\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function(): void { locked = true; }\nkeccak256.register = function(func: (data: Uint8Array) => BytesLike) {\n    if (locked) { throw new TypeError(\"keccak256 is locked\"); }\n    __keccak256 = func;\n}\nObject.freeze(keccak256);\n","import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\n\nfunction getChecksumAddress(address: string): string {\n//    if (!isHexString(address, 20)) {\n//        logger.throwArgumentError(\"invalid address\", \"address\", address);\n//    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = getBytes(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nconst Base36 = (function() {;\n    const result: Record<string, bigint> = { };\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\n\nfunction fromBase36(value: string): bigint {\n    value = value.toLowerCase();\n\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n        const result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address,\n            \"bad address checksum\", \"address\", address);\n\n        return result;\n    }\n\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) { result = \"0\" + result; }\n        return  getChecksumAddress(\"0x\" + result);\n    }\n\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n","import { getAddress } from \"../address/index.js\";\nimport {\n    keccak256 as _keccak256, sha256 as _sha256\n} from \"../crypto/index.js\";\nimport {\n    concat, dataLength, getBytes, hexlify, toBeArray, toTwos, toUtf8Bytes, zeroPadBytes, zeroPadValue,\n    assertArgument\n} from \"../utils/index.js\";\n\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return getBytes(zeroPadValue(value, 32)); }\n            return getBytes(getAddress(value));\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return getBytes(value);\n        case \"bool\":\n            value = (!!value ? \"0x01\": \"0x00\");\n            if (isArray) { return getBytes(zeroPadValue(value, 32)); }\n            return getBytes(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        let signed = (match[1] === \"int\");\n        let size = parseInt(match[2] || \"256\")\n\n        assertArgument((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n\n        if (isArray) { size = 256; }\n\n        if (signed) { value = toTwos(value, size); }\n\n        return getBytes(zeroPadValue(toBeArray(value), size / 8));\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        assertArgument(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n        assertArgument(dataLength(value) === size, `invalid value for ${ type }`, \"value\", value);\n\n        if (isArray) { return getBytes(zeroPadBytes(value, 32)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        assertArgument(count === value.length, `invalid array length for ${ type }`, \"value\", value);\n\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return getBytes(concat(result));\n    }\n\n    assertArgument(false, \"invalid type\", \"type\", type)\n}\n\n// @TODO: Array Enum\n\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPacked(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPackedKeccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _keccak256(solidityPacked(types, values));\n}\n\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPackedSha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _sha256(solidityPacked(types, values));\n}\n","import Decimal from \"decimal.js\";\nimport { parseUnits } from \"ethers\";\n\nexport const EXPONENT_INIT = 1;\nexport const EXPONENT_DECIMALS = 18;\nexport const EXPONENT_HALF_DECIMALS = EXPONENT_DECIMALS / 2;\nexport const INITIAL_EXPONENT = parseUnits(\"100000\", EXPONENT_DECIMALS);\nexport const INITIAL_EXPONENT_WC = parseUnits(\"10\", EXPONENT_HALF_DECIMALS);\nexport const INITIAL_EXPONENT_WT = parseUnits(\"10\", EXPONENT_HALF_DECIMALS);\n\nexport const INITIAL_INDEX_PRICE = \"0.01\";\nexport const ORACLE_PRICE_DECIMAL = 7;\nexport const MIN_PRICE_CHANGE_PPM = 1;\n\nexport const TWITTER_VOTE_AMOUNT = 10;\nexport const USER_VOTE_AMOUNT = 1;\nexport const ZERO = new Decimal(0);\n\nexport const MIN_DYNAMIC = new Decimal(0.001);\n","import Decimal from \"decimal.js\";\n\nexport type TokenPriceMap = Record<string, Decimal>;\nexport type TokenWeightMap = Record<string, Decimal>;\n\nexport enum VoteSource {\n  TWITTER = \"TWITTER\",\n  CHAIN = \"CHAIN\",\n  USER = \"USER\",\n}\n\nexport enum VotedAB {\n  A = \"A\",\n  B = \"B\",\n}\n","import { parseUnits } from \"ethers\";\nimport {\n  EXPONENT_DECIMALS,\n  EXPONENT_HALF_DECIMALS,\n  INITIAL_EXPONENT,\n  INITIAL_EXPONENT_WC,\n  INITIAL_EXPONENT_WT,\n} from \"../constants/constants\";\nimport { VoteSource, VotedAB } from \"../types/types\";\nimport Decimal from \"decimal.js\";\n\nexport class ExponentService {\n  private readonly decimals = EXPONENT_DECIMALS;\n  private readonly halfDecimals = EXPONENT_HALF_DECIMALS;\n  private readonly initialA = INITIAL_EXPONENT;\n  private readonly initialB = INITIAL_EXPONENT;\n  private readonly initialK = this.initialA * this.initialB;\n  private readonly initialWC = INITIAL_EXPONENT_WC;\n  private readonly initialWT = INITIAL_EXPONENT_WT;\n\n  private a!: bigint;\n  private b!: bigint;\n  private wc!: bigint;\n  private wt!: bigint;\n  private exponent!: bigint;\n\n  constructor() {\n    this.defaultState();\n  }\n\n  defaultState() {\n    this.a = this.initialA;\n    this.b = this.initialB;\n    this.wc = this.initialWC;\n    this.wt = this.initialWT;\n    this.exponent = 0n;\n  }\n\n  setState(a: bigint, b: bigint, wc: bigint, wt: bigint, exponent: bigint) {\n    this.a = a;\n    this.b = b;\n    this.wc = wc;\n    this.wt = wt;\n    this.exponent = exponent;\n  }\n\n  computeExponent(\n    voteAmount: number,\n    voteSource: VoteSource,\n    voteResult: VotedAB\n  ) {\n    const weight = this.computeVoteWeight(voteSource) * BigInt(voteAmount);\n\n    this.a += weight;\n    this.b += weight;\n    const newK = this.a * this.b;\n\n    if (voteResult === VotedAB.A) {\n      this.b += weight;\n      this.a = newK / this.b;\n    } else {\n      this.a += weight;\n      this.b = newK / this.a;\n    }\n\n    this.exponent = (newK * 10n ** 6n) / this.initialK;\n    return { a: this.a, b: this.b, exponent: this.exponent };\n  }\n\n  private computeVoteWeight(voteSource: VoteSource) {\n    const add = parseUnits(\"0.001\", this.halfDecimals);\n    this.wc += add;\n    this.wt += add;\n    const newK = this.wc * this.wt;\n\n    if (voteSource === VoteSource.CHAIN) {\n      this.wt += add;\n      this.wc = newK / this.wt;\n      return (this.wc * 10n ** BigInt(this.decimals)) / this.wt;\n    } else {\n      this.wc += add;\n      this.wt = newK / this.wc;\n      return (this.wt * 10n ** BigInt(this.decimals)) / this.wc;\n    }\n  }\n\n  getExponent() {\n    return {\n      a: this.a,\n      b: this.b,\n      wc: this.wc,\n      wt: this.wt,\n      exponent: this.exponent,\n    };\n  }\n\n  getExponentPrice() {\n    const exponentA = new Decimal(this.a.toString());\n    const exponentB = new Decimal(this.b.toString());\n    return exponentB.div(exponentA);\n  }\n\n  serialize() {\n    return JSON.stringify({\n      a: this.a + \"\",\n      b: this.b + \"\",\n      wc: this.wc + \"\",\n      wt: this.wt + \"\",\n      exponent: this.exponent + \"\",\n    });\n  }\n\n  deserialize(json: string) {\n    const obj = JSON.parse(json);\n    this.a = BigInt(obj.a);\n    this.b = BigInt(obj.b);\n    this.wc = BigInt(obj.wc);\n    this.wt = BigInt(obj.wt);\n    this.exponent = BigInt(obj.exponent);\n  }\n}\n","// src/lib/indexPrice.ts\nimport Decimal from \"decimal.js\";\nimport {\n  applyFinalAsymmetricNoise,\n  applyVolatilityNoise,\n  computeLogReturn,\n  computeVolatility,\n  tanhClampDelta,\n} from \"./math\";\nimport { TokenPriceMap, TokenWeightMap } from \"../types/types\";\nimport {\n  EXPONENT_INIT,\n  INITIAL_INDEX_PRICE,\n  MIN_DYNAMIC,\n  ZERO,\n} from \"../constants/constants\";\n\ntype ComputeBiasAdjustedIndexPriceOptions = {\n  maxDailyPercent?: number; // 24h cumulative maximum fluctuation percentage (e. g. 3 means ± 3%)\n  tokenWeight?: number; // Weight of the impact of token price fluctuations on the index\n  price24hAgo?: Decimal; // Used to limit 24-hour cumulative volatility (can be index or token price)\n  biasShiftWeight?: number; // Voting separately pushes the weight of the price\n  biasScaleWeight?: number; // Vote to enlarge/reduce the weight of the price increase or decrease.\n  biasShiftCapPercent?: number; // The most single vote can push the index up or down.\n  biasScaleCapPercent?: number; // The maximum amount of increase or decrease that can be zoomed in/out at a time.\n  prevTokenDeltas?: Decimal[];\n  showLog?: boolean;\n  volatilityAmplifier?: number;\n  noiseRange?: number;\n};\n\nexport type NextIndex = {\n  nextIndexPrice: Decimal;\n  delat: Decimal;\n};\n\ntype configOptions = {\n  tokenWeight: Decimal;\n  biasShiftWeight: Decimal;\n  biasScaleWeight: Decimal;\n};\n\nfunction config(options?: ComputeBiasAdjustedIndexPriceOptions): configOptions {\n  const tokenWeight = new Decimal(options?.tokenWeight ?? 0.5);\n  const biasShiftWeight = new Decimal(options?.biasShiftWeight ?? 0.25);\n  const biasScaleWeight = new Decimal(options?.biasScaleWeight ?? 0.25);\n  return {\n    tokenWeight,\n    biasShiftWeight,\n    biasScaleWeight,\n  };\n}\n\nexport function computeBiasAdjustedIndexPrice(\n  prices: TokenPriceMap,\n  prevPrices: TokenPriceMap,\n  weights: TokenWeightMap,\n  exponentPrice: Decimal,\n  prevIndexPrice: Decimal = new Decimal(INITIAL_INDEX_PRICE),\n  options?: ComputeBiasAdjustedIndexPriceOptions\n): NextIndex {\n  const symbols = Object.keys(prices);\n  if (symbols.length < 2)\n    return {\n      nextIndexPrice: ZERO,\n      delat: ZERO,\n    };\n  const prevSymbols = Object.keys(prevPrices);\n  if (prevSymbols.length < 2)\n    return {\n      nextIndexPrice: ZERO,\n      delat: ZERO,\n    };\n\n  const aaSymbol = symbols[0];\n  const bbSymbol = symbols[1];\n\n  const aaPrice = prices[aaSymbol];\n  const aaPrevPrice = prevPrices[aaSymbol];\n  const bbPrice = prices[bbSymbol];\n  const bbPrevPrice = prevPrices[bbSymbol];\n\n  const aaWeight = weights[aaSymbol];\n  const bbWeight = weights[bbSymbol];\n\n  // Check if it is valid\n  if (\n    aaPrice.lte(0) ||\n    aaPrevPrice.lte(0) ||\n    bbPrice.lte(0) ||\n    bbPrevPrice.lte(0)\n  ) {\n    return {\n      nextIndexPrice: ZERO,\n      delat: ZERO,\n    };\n  }\n\n  // Configs\n  const { tokenWeight, biasShiftWeight, biasScaleWeight } = config(options);\n\n  // Step 1: Calculate log return\n  const rA = computeLogReturn(aaPrice, aaPrevPrice);\n  const rB = computeLogReturn(bbPrice, bbPrevPrice);\n\n  // Step 2: Weighted combination (AA forward, BB reverse)\n  const totalTokenWeight = aaWeight.add(bbWeight);\n  if (totalTokenWeight.eq(0))\n    return {\n      nextIndexPrice: ZERO,\n      delat: ZERO,\n    };\n\n  // Step 3: Weighted price return (token delta)\n  const tokenDelta = aaWeight\n    .mul(rA)\n    .sub(bbWeight.mul(rB))\n    .div(totalTokenWeight);\n\n  // === Step 3: BiasShiftDelta → Voting directly drives prices (exponent > 1 drives up,< 1 drives down) ===\n  const biasShiftStrengthDelta = exponentPrice.sub(EXPONENT_INIT); // Both positive and negative can be\n\n  // === Step 4: BiasScaleDelta → Vote to zoom in/out on price fluctuations (same direction) ===\n  const rawBiasScaleDelta = tokenDelta.mul(exponentPrice.sub(EXPONENT_INIT));\n\n  // === Step 5: Combine all effects ===\n  let rawCombinedDelta = tokenDelta\n    .mul(tokenWeight)\n    .add(biasShiftStrengthDelta.mul(biasShiftWeight))\n    .add(rawBiasScaleDelta.mul(biasScaleWeight));\n\n  // Step 5: Adaptive delta clipping (maxStepPercent removed, based solely on tokenDelta history)\n  const recentVolatility = computeVolatility(options?.prevTokenDeltas ?? []);\n  const dynamicMax = Decimal.max(recentVolatility.mul(3), MIN_DYNAMIC); // Avoid 0, make sure there is a little sensitivity\n  let combinedDelta = Decimal.tanh(rawCombinedDelta.div(dynamicMax)).mul(\n    dynamicMax\n  );\n\n  if (options?.showLog) {\n    console.log(`rA:${rA.toString()}`);\n    console.log(`rB:${rB.toString()}`);\n    console.log(`tokenDelta: ${tokenDelta.toString()}`);\n    console.log(`biasShiftStrengthDelta: ${biasShiftStrengthDelta.toString()}`);\n    console.log(`rawBiasScaleDelta: ${rawBiasScaleDelta.toString()}`);\n    console.log(`rawCombinedDelta: ${rawCombinedDelta.toString()}`);\n    console.log(`recentVolatility: ${recentVolatility.toString()}`);\n    console.log(`dynamicMax: ${dynamicMax.toString()}`);\n    console.log(`combinedDelta: ${combinedDelta.toString()}`);\n  }\n\n  // Step 5.3: Daily Fluctuation Smoothing Limiting (based on index or token price)\n  if (options?.maxDailyPercent && options?.price24hAgo) {\n    const return24h = Decimal.ln(prevIndexPrice.div(options.price24hAgo));\n    const effectiveDailyDelta = combinedDelta.add(return24h);\n    const cappedEffective = tanhClampDelta(\n      effectiveDailyDelta,\n      options.maxDailyPercent\n    );\n    combinedDelta = cappedEffective.sub(return24h);\n\n    if (options?.showLog) {\n      console.log(\n        `Daily combinedDelta:${combinedDelta.toString()}, return24h:${return24h.toString()}, effectiveDailyDelta:${effectiveDailyDelta.toString()}, cappedEffective:${cappedEffective.toString()}`\n      );\n    }\n  }\n\n  if (options?.volatilityAmplifier && options?.noiseRange) {\n    combinedDelta = applyVolatilityNoise(combinedDelta, {\n      volatilityAmplifier: options.volatilityAmplifier,\n      noiseRange: options.noiseRange,\n    });\n  }\n\n  // Step 6: Multiplication of exp(Δ) from the previous price to arrive at the current indexPrice ratio (relative to the previous round)\n  const indexPriceMultiplier = Decimal.exp(combinedDelta);\n\n  const nextIndexPrice = prevIndexPrice.mul(indexPriceMultiplier);\n\n  return {\n    nextIndexPrice,\n    delat: combinedDelta,\n  };\n}\n\ntype PredictedIndexImpact = {\n  predictedIndexPrice: Decimal;\n  deltaPercent: Decimal; // (predicted / prev - 1)\n};\n\nexport function predictIndexImpactFromExponentOnly(\n  exponentPrice: Decimal,\n  prevIndexPrice: Decimal,\n  options?: ComputeBiasAdjustedIndexPriceOptions\n): PredictedIndexImpact {\n  // Configs\n  const { biasShiftWeight } = config(options);\n\n  // Step 1: tokenDelta = 0, so rawScale = 0, leaving only the bias shift item\n  const biasShiftStrengthDelta = exponentPrice.sub(EXPONENT_INIT);\n\n  const rawCombinedDelta = biasShiftStrengthDelta.mul(biasShiftWeight); // no scale contribution\n\n  // Step 2: compute dynamicMax based on prevTokenDeltas\n  const recentVolatility = computeVolatility(options?.prevTokenDeltas ?? []);\n  const dynamicMax = Decimal.max(recentVolatility.mul(3), MIN_DYNAMIC); // Avoid 0, make sure there is a little sensitivity\n  let combinedDelta = Decimal.tanh(rawCombinedDelta.div(dynamicMax)).mul(\n    dynamicMax\n  );\n\n  // Step 3: Daily Fluctuation Smoothing Limiting (based on index or token price)\n  if (options?.maxDailyPercent && options?.price24hAgo) {\n    const return24h = Decimal.ln(prevIndexPrice.div(options.price24hAgo));\n    const effectiveDailyDelta = combinedDelta.add(return24h);\n    const cappedEffective = tanhClampDelta(\n      effectiveDailyDelta,\n      options.maxDailyPercent\n    );\n    combinedDelta = cappedEffective.sub(return24h);\n  }\n\n  // Step 4: Apply exp(Δ) to prevIndexPrice\n  const indexPriceMultiplier = Decimal.exp(combinedDelta);\n  const predictedIndexPrice = prevIndexPrice.mul(indexPriceMultiplier);\n\n  // Output percentage change and log change\n  const deltaPercent = predictedIndexPrice.div(prevIndexPrice).sub(1); // linear %\n\n  if (options?.showLog) {\n    console.log(`biasShiftStrengthDelta: ${biasShiftStrengthDelta.toString()}`);\n    console.log(`rawCombinedDelta: ${rawCombinedDelta.toString()}`);\n    console.log(`recentVolatility: ${recentVolatility.toString()}`);\n    console.log(`dynamicMax: ${dynamicMax.toString()}`);\n    console.log(`combinedDelta: ${combinedDelta.toString()}`);\n    console.log(`indexPriceMultiplier: ${indexPriceMultiplier.toString()}`);\n    console.log(`deltaPercent: ${deltaPercent.toString()}`);\n  }\n\n  return {\n    predictedIndexPrice,\n    deltaPercent,\n  };\n}\n","import { solidityPackedKeccak256 } from \"ethers\";\nimport {\n  MIN_PRICE_CHANGE_PPM,\n  ORACLE_PRICE_DECIMAL,\n} from \"../constants/constants\";\n\nexport const getPriceAtomicResolution = (price: number): number => {\n  if (!price || !isFinite(price) || price <= 0) return 0;\n\n  if (price >= 1e4) return -9;\n  if (price >= 1e3) return -8;\n  if (price >= 3e2) return -7; // 300~999\n  if (price >= 5e1) return -6; // 50~299\n  if (price >= 1) return -5; // 1~49.999...\n  if (price >= 0.1) return -4; // 0.1~0.999...\n  if (price >= 0.01) return -3; // 0.01~0.0999\n  if (price >= 0.001) return -2; // 0.001~0.00999\n  if (price >= 0.0001) return -1; // 0.0001~0.000999\n  if (price >= 0.00001) return 0; // 0.00001~0.000099...（Such as SHIB）\n\n  return 0;\n};\n\nexport const generateEventHash = (eventTag: string, title: string): string => {\n  return solidityPackedKeccak256([\"string\", \"string\"], [eventTag, title]);\n};\n\nexport const getMarketParameters = (ticker: string, price: string) => {\n  return {\n    ticker: ticker,\n    priceExponent: -ORACLE_PRICE_DECIMAL,\n    minPriceChange: MIN_PRICE_CHANGE_PPM,\n    atomicResolution: getPriceAtomicResolution(Number(price)),\n    quantumConversionExponent: -9,\n    stepBaseQuantums: 1_000_000,\n    subticksPerTick: 100_000,\n  };\n};\n"],"mappings":"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","names":["bytes","bytes","mask","bytes","output","BN_0","BN_1","_format","bytes","BN_0","BN_0","value","Decimal","Decimal","VoteSource","VotedAB","Decimal","Decimal","Decimal"]}